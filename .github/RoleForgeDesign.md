# RoleForge Design

## 1. Mission & Landscape
- RoleForge is an LLM-driven roleplay platform motivated by Talemate and SillyTavern, with a TypeScript/Node + React/Vite stack, modular agent orchestration, SQLite persistence, and a Socket.io-backed chat shell for live scenes, characters, lore, and media playback ([README.md](README.md#L1-L60)).
- Phases 1–5 (core backend, LLM integration, agents, characters/lore, world hierarchy) plus round/audit features are production ready while Phases 6–8 (visual/audio/polish) remain in design; the current status, stack, and round tracking commitments are documented in the implementation journal ([DevDocumentation/IMPLEMENTATION_STATUS.md](DevDocumentation/IMPLEMENTATION_STATUS.md#L1-L200)).
- A consolidated documentation index keeps track of every reference doc and schema so engineers can find the living spec for agents, lore, UI, and vectorization ([DevDocumentation/DOCUMENTATION_CONSOLIDATED_INDEX.md](DevDocumentation/DOCUMENTATION_CONSOLIDATED_INDEX.md#L1-L200)).

## 2. Architecture
+### Backend agents & API shell
+- `backend/src/server.ts` wires Express, multer, and Socket.io into a single orchestrator entry point that exposes REST CRUD for worlds/campaigns/arcs/scenes, lorebook operations, persona/character endpoints, and `/api/scenes/:id/session`, `/api/scenes/:id/continue-round`, and round lifecycle hooks while replaying agent status events to every `scene-<id>` room ([backend/src/server.ts](backend/src/server.ts#L1-L350)).
+- The `Orchestrator` builds session context, matches lore entries, queues summaries, rounds, and vectorization jobs, tracks active characters/round numbers, and emits `agentStatus`/`roundCompleted` events for the UI ([backend/src/agents/Orchestrator.ts](backend/src/agents/Orchestrator.ts#L1-L400)).
+- Every agent extends `BaseAgent`, which resolves the per-agent LLM profile from `config.json`, sanitizes Nunjucks context, renders templates, and falls back safely when calls fail while `backend/src/llm/client.ts` enforces retries, backoff, token trimming, and template rendering for OpenAI-compatible and custom endpoints ([backend/src/agents/BaseAgent.ts](backend/src/agents/BaseAgent.ts#L1-L260), [backend/src/llm/client.ts](backend/src/llm/client.ts#L1-L200)).
+- Configuration lives in `localConfig/config.json`—default and custom profiles, sampler controls, visual-agent toggles, ComfyUI connectors, and per-agent `returnsJson` toggles that feed directly into `BaseAgent` and `Orchestrator` ([localConfig/config.json](localConfig/config.json#L1-L200)).
+- The agent catalog (Narrator, Character, Director, World, Summarize, Visual, Creator, etc.) is spelled out in the design document so each prompt template and intention stays isolated ([DevDocumentation/agent-design.md](DevDocumentation/agent-design.md#L1-L220)).
+- Specialized agents are minimal wrappers around `BaseAgent`: `NarratorAgent` and `CharacterAgent` simply select their respective template (`narrator` or `character`), call `callLLM` with the orchestrator-provided context, and pass back `cleanResponse` output so downstream orchestration never has to handle raw LLM noise ([backend/src/agents/NarratorAgent.ts](backend/src/agents/NarratorAgent.ts#L1-L20), [backend/src/agents/CharacterAgent.ts](backend/src/agents/CharacterAgent.ts#L1-L20)).
- **Prompt pipeline**: `Orchestrator.processUserInput` first seeds `AgentContext` with history, character states, scene/world summaries, director guidance, lore, trackers, and user persona before calling each agent ([backend/src/agents/Orchestrator.ts](backend/src/agents/Orchestrator.ts#L569-L1185)). `BaseAgent.renderTemplate` then uses Nunjucks to combine that context with the agent-specific `.njk` file, escaping problematic strings, while `renderLLMTemplate`/`renderRawLLMTemplate` convert that output into either `ChatMessage[]` for OpenAI-style profiles or raw prompt text for custom clients. `callLLM` routes to `chatCompletion` for OpenAI-compatible profiles (which trims histories, retries, and streams per `backend/src/llm/client.ts`) or to `customLLMRequest` for custom profiles, ensuring every prompt—regardless of transport—starts from the same orchestrator-driven context ([backend/src/agents/BaseAgent.ts](backend/src/agents/BaseAgent.ts#L1-L260), [backend/src/llm/client.ts](backend/src/llm/client.ts#L1-L240)).
+- `ConfigManager` still drives profile discovery (including vector config), feature toggles, and sampler defaults, while `chatCompletion` handles retries/backoff, prompt trimming, streaming flag support, response-format options, and fallback profiles so agents hit OpenAI-compatible or custom endpoints reliably even under transient errors ([backend/src/configManager.ts](backend/src/configManager.ts#L1-L200), [backend/src/llm/client.ts](backend/src/llm/client.ts#L1-L240)).

+### Data services & persistence
+- `WorldService`, `CampaignService`, and `SceneService` encode the World→Campaign→Arc→Scene hierarchy, enforce slug/round numbering, persist campaign state, and expose lore context/round metadata for agents ([backend/src/services/WorldService.ts](backend/src/services/WorldService.ts#L1-L150), [backend/src/services/CampaignService.ts](backend/src/services/CampaignService.ts#L1-L200), [backend/src/services/SceneService.ts](backend/src/services/SceneService.ts#L1-L320)).
+- `SceneService` also owns round lifecycle state: it starts/completes rounds atomically, increments `Scenes.currentRoundNumber`, writes `SceneRounds` metadata (including active characters/vectorization flags), resets scenes plus generated media and vector files, and supplies helper queries used by the orchestrator to fetch lore context or round detail ([backend/src/services/SceneService.ts](backend/src/services/SceneService.ts#L1-L400)).
+- `MessageService` canonicalizes sender/source/sourceId, counts tokens, associates messages with `SceneRounds`, cleans up generated assets when messages are removed, supports message reordering, and exposes round-aware getters so the orchestrator can stream the exact history it needs for prompts ([backend/src/services/MessageService.ts](backend/src/services/MessageService.ts#L1-L280)).
+- Character, persona, and override lookups deep-merge base entities with world/campaign overrides, while `CharacterService` also exposes avatar upload/delete utilities for the UI ([backend/src/services/CharacterService.ts](backend/src/services/CharacterService.ts#L1-L200)).
+- Lorebooks live in a secondary SQLite store under `data/lorebooks.db`; `LorebookService` handles import/export, per-entry matching metadata, and the join tables that bind lorebooks to worlds/campaigns ([backend/src/services/LorebookService.ts](backend/src/services/LorebookService.ts#L1-L320)).

### Frontend shell & UI abstractions
- `frontend/src/App.tsx` keeps a single Socket.io connection, exposes eight tabs (`chat`, `characters`, `lore`, `personas`, `comfyui`, `worlds`, `llm`, `debug`), loads world/campaign/scene hierarchies, manages persona/character/lore state, and toggles the left/right `Panel` shells ([frontend/src/App.tsx](frontend/src/App.tsx#L1-L260)).
- The world builder (`WorldManager.tsx`) loads every world/campaign/arc/scene, renders the hierarchy with glassmorphic styling, and surfaces lore assignment, new scene creation, and CRUD operations referenced by the backend services ([frontend/src/WorldManager.tsx](frontend/src/WorldManager.tsx#L1-L250)).
- `CharacterManager.tsx` handles UUID-backed CRUD, avatar cropping, regen, import/export, and field-specific LLM refresh calls for every persona/character trait while `LoreManager.tsx` offers tabbed views for lorebooks, entries, import/export, pagination, and search filters ([frontend/src/CharacterManager.tsx](frontend/src/CharacterManager.tsx#L1-L220), [frontend/src/LoreManager.tsx](frontend/src/LoreManager.tsx#L1-L220)).
- The chat surface (`components/Chat.tsx`) auto-scrolls, streams Markdown/imagery, exposes message editing/reordering, listens for `agentStatus` and `roundCompleted`, and routes inputs to `/api/scenes/:selectedScene/messages` plus the continue-round endpoint ([frontend/src/components/Chat.tsx](frontend/src/components/Chat.tsx#L1-L240)).
- `Panel.tsx` is the reusable glass panel wrapper for the new left/right drawers, and `WorldStatus.tsx` lets players inspect/edit world state, trackers, objectives, relationships, and current character states via double-click inline editors that send PUTs to `/api/campaigns/:id/state` ([frontend/src/components/Panel.tsx](frontend/src/components/Panel.tsx#L1-L40), [frontend/src/components/WorldStatus.tsx](frontend/src/components/WorldStatus.tsx#L1-L240)).

## 3. Functionality matrix
- **Multi-agent narrative loop**: sequential Summarize→Director→World→Narrator→Character→Visual agents run per scene via `Orchestrator` and share Nunjucks templates, while `BaseAgent` enforces profile overrides and `chatCompletion` deals with retries (`backend/src/agents/Orchestrator.ts`, `backend/src/llm/client.ts`).
- **Persistent scenes with rounds**: every `_Scenes` row tracks `currentRoundNumber`; `SceneService.startRound`/`completeRound`/`getRoundData` plus `MessageService` round helpers keep the UI synchronized and trigger vectorization (`SceneService.ts`, `MessageService.ts`).
- **World/campaign hierarchy editing**: the UI mirrors the DB services so authors can create worlds, attach lorebooks, rearrange arcs/scenes, and push state updates through `WorldService`/`CampaignService`/`SceneService` (`WorldManager.tsx`).
- **Characters & personas**: frontend managers call `/api/characters`, `/api/personas`, and `/api/characters/generate`, while keyed override merge ensures every scene gets tailored character state ([CharacterManager.tsx](frontend/src/CharacterManager.tsx#L1-L160), `CharacterService.ts`).
- **Lorebooks**: CRUD, pagination, import/export, and entry editing exist in the UI and feed into `LorebookService` for matching before each agent run (`LoreManager.tsx`, `LorebookService.ts`).
- **Chat/slots**: `Chat.tsx` handles visual hints, inline editing, message moves/delete, regen buttons, round counters, and socket-driven state updates; it calls `/api/messages` routes that are backed by `MessageService`. 
- **Visual & config controls**: `localConfig/config.json` enables `visualAgentEnabled` and ComfyUI workflows, and the frontend exposes `ComfyConfigModal` plus `LLMConfigModal` (configured in `App.tsx`).
- **World status editing**: `WorldStatus.tsx` lets users tweak trackers, objectives, relationships, and character state inline; edits flow back to `CampaignService.updateState` for persistence.
- **Documentation & roadmap**: every major scope is recorded in the consolidated index and implementation journal so new contributors can find feature specs and completion notes (`DevDocumentation/DOCUMENTATION_CONSOLIDATED_INDEX.md`, `DevDocumentation/IMPLEMENTATION_STATUS.md`).

## 4. Operation flow
1. The React shell maintains one Socket.io connection and listens for `sceneAdvanced`, `stateUpdated`, `messageUpdated`, `roundCompleted`, `regenStarted`, and `regenFailed` events, keeping session context, world state, and the chat window in sync with server emissions (`App.tsx`, `Chat.tsx`).
2. When a user sends input or hits continue-round, the UI POSTs to `/api/scenes/:sceneId/messages` or `/api/scenes/:sceneId/continue-round`; the backend runs the orchestrator path, logs messages via `MessageService`, updates world/campaign state through `SceneService` and `CampaignService`, and emits `agentStatus`/`roundCompleted` plus `stateUpdated` before saving lore and message metadata (`server.ts`, `SceneService.ts`, `MessageService.ts`).
3. The orchestrator builds context from merged character overrides, active lorebooks, campaign state, and recent messages, then runs Summarize→Director→World→Narrator→Character→Visual/Creator agents in sequence to keep continuity, pace, and world state consistent (`Orchestrator.ts`, `agent-design.md`).
4. VectorizationAgent (alongside `sceneRounds` metadata) kicks off asynchronously after each round with the round’s messages; the client listens on `roundCompleted` to refresh the UI once the backend has incremented the round counter.
5. Managers for characters, personas, worlds, and lore call the backend CRUD services which in turn update SQLite tables, override caches, and recommended lore entries so the next orchestrator run sees the new data (`CharacterService.ts`, `LorebookService.ts`, `WorldService.ts`).

## 5. Site paths & UI workspaces
| UI area | Entry file | Description |
| --- | --- | --- |
| Chat + rounds | [frontend/src/components/Chat.tsx](frontend/src/components/Chat.tsx#L1-L220) | Streaming Markdown + images, inline editing/move/delete, active round counter, continue-round button, `agentStatus` + `roundCompleted` feedback. |
| World builder | [frontend/src/WorldManager.tsx](frontend/src/WorldManager.tsx#L1-L220) | CRUD world → campaign → arc → scene, lore assignments, auto-expanding hierarchy, lorebook links. |
| Character management | [frontend/src/CharacterManager.tsx](frontend/src/CharacterManager.tsx#L1-L200) | CRUD with avatar cropper, regen/import/copy dialogs, field-specific LLM updates, integration with backend. |
| Lorebooks | [frontend/src/LoreManager.tsx](frontend/src/LoreManager.tsx#L1-L220) | Lorebook list, entry editor, import/export, pagination, filtering, toast-backed alerts. |
| World status panel | [frontend/src/components/WorldStatus.tsx](frontend/src/components/WorldStatus.tsx#L1-L220) | Expandable panels for dynamic facts, trackers, objectives, relationships, character states with inline editors that PUT to `/api/campaigns/:id/state`. |
| Panel shell | [frontend/src/components/Panel.tsx](frontend/src/components/Panel.tsx#L1-L30) | Reusable left/right drawer with close button and consistent glass styling so the layout matches the UI vision. |
| App shell | [frontend/src/App.tsx](frontend/src/App.tsx#L1-L260) | Central state, persona persistence, Socket.io listeners, modals (LLM/comfy/config), and tab routing (`currentTab` manages chat/characters/lore/personas/worlds/llm/debug). |

## 6. Deployment & scripts
- Root workspace defines `dev`, `dev:backend`, `dev:frontend`, and a combined `build` that compiles backend TypeScript and then runs Vite’s build so production artifacts align (`package.json`).
- Backend dev/run/type checking is handled via `nodemon`+`tsx`, `vitest`, and `tsc` scripts defined in `backend/package.json`; frontend development/preview/build use `vite` plus ESLint hooks (`backend/package.json`, `frontend/package.json`).
- Shared tooling (tokenizer, jsonrepair) lives in workspace dependencies while each package keeps TypeScript `5.9.x` pinned for parity across build/test suites.

## 7. Documentation & knowledge base
- The consolidated index records whether every doc is complete, in-use, or archived so contributors can locate specs quickly (`DevDocumentation/DOCUMENTATION_CONSOLIDATED_INDEX.md`).
- The implementation status file records the phase roadmap, system architecture summary, and confirmed completion of Phases 1–5 while keeping future work logged for Phases 6–8 (`DevDocumentation/IMPLEMENTATION_STATUS.md`).
- Agent-specific intent, prompts, and orchestration flow are defined in the agent design doc (`DevDocumentation/agent-design.md`), giving clear handoffs for modifying or extending any agent.

## 8. Configuration & next steps
- LLM profiles, feature toggles, and ComfyUI settings come from `localConfig/config.json`. Adjusting `features.visualAgentEnabled` or sampler values immediately affects how `BaseAgent` resolves templates and which agents run (`localConfig/config.json`).
- The App also fetches `/api/debug-config` to sync feature flags and logs, ensuring the frontend mirrors backend debug behavior (`App.tsx`).
- New work should keep updating the consolidated index and implementation status documents so this design reference remains accurate before Phases 6–8 specifications arrive.
